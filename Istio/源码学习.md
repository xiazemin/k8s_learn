https://github.com/1046102779/istio-learning/

https://www.kubernetes.org.cn/4379.html

https://cloudnative.to/blog/istio-pilot/
https://zhuanlan.zhihu.com/p/259207332
https://zhuanlan.zhihu.com/p/259756638


Pilot 的代码主要分为两部分:

pilot-discovery
pilot-agent
其中 pilot-agent 负责数据面 Sidecar 实例的生命周期管理，而 pilot-discovery 负责控制面流量管理配置及路由规则的生成和下发。

 pilot-discovery 的主服务，包含了三个比较重要的组件：

Config Controller：从不同来源接收流量控制和路由规则等 Istio 的配置，并响应各类事件。
Service Controller：从不同注册中心同步服务及实例，并响应各类事件。
EnvoyXdsServer：核心的 xDS 协议推送服务，根据上面组件的数据生成 xDS 协议并下发。


Config Controller 比较核心的就是对接 Kubernetes，从 kube-apiserver 中 Watch 集群中的 VirtualService、ServiceEntry、DestinationRules 等配置信息，有变化则生成 PushRequest 推送至 EnvoyXdsServer 中的推送队列。除此之外，还支持对接 MCP(Mesh Configuration Protocol) 协议的 gRPC Server，如 Nacos 的 MCP 服务等，只需要在 meshconfig 中配置 configSources 即可。最后一种是基于内存的 Config Controller 实现，通过 Watch 一个文件目录，加载目录中的 yaml 文件生成配置数据，主要用来测试。


Service Controller 目前原生支持 Kubernetes 和 Consul，注册在这些注册中心中的服务可以无痛接入 Mesh，另外一种比较特殊，就是 ServiceEntryStore，它本质是储存在 Config Controller 中的 Istio 配置数据，但它描述的却是集群外部的服务信息，详情可阅读文档 ServiceEntry，Istio 通过它将集群外部，如部署在虚拟机中的服务、非 Kubernetes 的原生服务同步到 Istio 中，纳入网格统一进行流量控制和路由，所以 ServiceEntryStore 也可以视为一种注册中心。还有一种就是 Mock Service Registry，主要用来测试。


ConfigStores 是一个列表，里面存储了各类 Istio 配置文件，包括 ServiceEntry 、WorkloadEntry 等服务数据，也包括 VirtualService、DestinationRules、Sidecar 等流量控制、路由规则的配置数据，pilot-discovery 将这些 ConfigStores 聚合成一个 configController 统一进行管理，之后再从其中衍生出 IstioConfigStore，将其作为 serviceEntryStore 的配置源。serviceEntryStore 其实就是 ServiceEntry Controller，响应 ServiceEntry 和 WorkloadEntry 这类服务信息的变化。

EnvoyXdsServer 比较核心，一切与 xDS 协议相关的接收、转换、下发操作都由它完成。EnvoyXdsServer 对接所有集群中的边车代理，如 Envoy、MOSN 等，当配置或服务发生变化时主动推送，也会响应代理发送的请求，依据请求的信息下发相应的 xDS 配置。

接口设计
在接口设计方面，Pilot 主要有两类接口：一种是 Store 类接口，定义对资源的增删改查等方法；另一种是 Controller 类接口，定义了 RegisterEventHandler 和 Run 方法。

Store 类接口主要指 ConfigStore 接口，以及它衍生出的 IstioConfigStore，后者操作的对象为 Istio 定义的配置类型，如 VirtualService、ServiceEntry 等。

而 Controller 类接口指基于 ConfigStore 定义的 ConfigStoreCache 接口，这个接口在哪里用到了呢？之前讨论初始化流程的时候，分析过 Pilot 的 Server 的结构


ServiceEntryStore
在多点落地 ServiceMesh 的过程中，大量的用到了 ServiceEntry ，每一个 Dubbo 服务都会映射一个 ServiceEntry 创建在 Kubernetes 里。 ServiceEntry 的作用就是将集群外部的服务注册到 Pilot 中，再统一由 ServiceController 进行管理。相应的，管理外部服务实例的对象为 WorkloadEntry ， ServiceEntry 可以通过 LabelSelector 筛选出自身对应的实例。

ServiceEntry 是作为 CR (Custome Resource) 保存在 Kubernetes 集群里的（也可以通过 MCP 服务直接发送给 Pilot ），暂时只讨论在集群中创建 CR 的情况。在上一篇源码分析中我们介绍到， Pilot 是通过 ConfigController 来监听创建在集群中的 CR 的， ServiceEntry 也不例外，保存这些 CR 的 ConfigStore 会被转化为 ServiceEntryStore 中的 store （转化的详情见上一篇源码分析），这就是最终 Pilot 存储 ServiceEntry 的地方。当监听的资源推送更改的事件时，会触发 ServiceEntryStore 对应的 handler 处理后续的流程。

EnvoyXdsServer
EnvoyXdsServer 主要负责 Pilot 中 xDS 协议的生成和下发，接收并处理 configController 和 serviceController 推送的 PushRequest ，与集群中所有的数据面代理进行 gRPC 通信，并处理它们的请求。

